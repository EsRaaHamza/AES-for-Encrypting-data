#include <iostream>
#include <sstream>
#include <string>
#include <iomanip>
using namespace std;



unsigned int rotl(unsigned int  c)
{
	unsigned int x = c << 8;
	unsigned int y = c >> 24 ;
	unsigned int z = x|y;
	return z ;


}

static const unsigned int sbox[256] =

{    //0   1     2     3     4     5     6     7     8      9    a     b     c      d     e    f
	/*0*/	0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
	/*1*/	0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
	/*2*/	0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
	/*3*/	0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
	/*4*/	0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
	/*5*/	0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
	/*6*/	0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
	/*7*/	0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
	/*8*/	0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
	/*9*/	0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
	/*a*/	0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
	/*b*/	0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
	/*c*/	0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
	/*d*/	0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
	/*e*/	0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
	/*f*/	0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16

};




unsigned int * addround (unsigned int plain [] , unsigned int key [])
{

	static unsigned int addroundresult [16];
	for (int i =0 ; i<16 ; i++)
	{

		addroundresult[i]= (plain[i] ^ key[i]) ;

	}
	return addroundresult;
}



unsigned int subbyte(unsigned int num)
{
	return sbox[num];
}





unsigned int Rcon[255] = 
{

	0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
	0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
	0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
	0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d,
	0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab,
	0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d,
	0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25,
	0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01,
	0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d,
	0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa,
	0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a,
	0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02,
	0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
	0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
	0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
	0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
	0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f,
	0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5,
	0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33,
	0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb};








unsigned int * expandkey(unsigned int key[16])
{
	static unsigned int word [44];
	unsigned int wordelement;
	int j=0;

	unsigned int temp;
	for(int i = 0; i < 13 ; i=i+4)
	{


		wordelement = (key [i])<<24 | (key[i+1])<<16 |(key [i+2])<<8 | key [i+3];
		word [j] =  wordelement;


		if (j<4)
			j++;
	}

	unsigned int rotate;
	unsigned int temp1;
	unsigned int temp1dash;
	unsigned int temp2;
	unsigned int temp2dash;
	unsigned int temp3;
	unsigned int temp3dash ;
	unsigned int temp4;
	unsigned int temp4dash;

	for(int i = 4 ; i < 44; i++)
	{

		temp = word [i - 1];
		if (i %4 ==0 ) //needs generator
		{

			rotate = rotl(temp);
			temp1 = rotate & 0xff;
			temp1dash = subbyte (temp1); 
			temp2 = (rotate & 0xff00)>>8 ;
			temp2dash = subbyte (temp2);
			temp3 = (rotate & 0xff0000)>>16;
			temp3dash = subbyte (temp3);
			temp4 = (rotate & 0xff000000)>>24;
			temp4dash = subbyte (temp4);

			temp = temp1dash | temp2dash <<8 | temp3dash << 16 | temp4dash<<24;

			temp =   temp ^ (Rcon [i/4] << 24);          //------------------> needs edit
		}
		word[i] = word[i-4] ^ temp;

	}



	return word;
}





unsigned int * splitkey (unsigned int word [44] ,int i)
{

	static unsigned int key [16];
	unsigned int byte0;
	unsigned int byte1;
	unsigned int byte2;
	unsigned int byte3;
	int j =0;
	int kk= i + 4 ;
	for ( i ; i<kk ; i++)
	{
		byte0 = (word[i]&0xff000000) >>24;
		key [j] = byte0;
		if (j<16)
			j++;
		byte1 = (word[i]&0x00ff0000) >> 16;
		key [j] = byte1;
		if (j<16)
			j++;
		byte2 = (word[i]&0x0000ff00) >> 8;
		key [j] = byte2;
		if (j<16)
			j++;
		byte3 = word[i]&0x000000ff;
		key [j] = byte3;
		if (j<16)
			j++;
	}


	return key;
}





unsigned int * shiftrows (unsigned int plaintext[16])
{
	int x = 24 ;
	static unsigned int final [16];
	unsigned int allcombined;
	unsigned int sl;
	unsigned int sr;
	unsigned int results;

	for (int i = 1;i<4;i++)
	{

		allcombined = plaintext [i]<<24 | (plaintext [i+4]<<16) |(plaintext [i+8]<<8)| (plaintext[i+12]);
		sl= allcombined<<(8*i);
		sr = allcombined >> x;
		results = sl|sr; 

		final [i+12] = results & 0xff;
		final [i+8] = (results &0xff00)>>8;
		final [i+4] = (results & 0xff0000)>>16;
		final [i] = (results  & 0xff000000)>>24;
		x=x-8;
	}

	final[0] = plaintext[0];
	final [4] = plaintext[4];
	final [8] = plaintext [8];
	final [12] = plaintext [12];


	return final;
}




unsigned int result1 ;
unsigned int result2 ;
unsigned int xorr;
unsigned int mul(unsigned int x , unsigned int y  )
{

	xorr=0x00000000;
	xorr = y & 0x00000080;

	if (xorr == 0x00000000) //a5er bit kant b zero ... shift left only
	{

		result1 = y << 25; 
		result2 = result1 >>24;
	}
	else if (xorr == 0x00000080)
	{
		result1 = y << 25; 

		result2 = result1 >>24;
		result2 = result2 ^ 0x0000001b ;
	}
	return result2;
}


unsigned int * mixcol (unsigned int plaintext [16])
{
	unsigned int temp ;
	static unsigned int result[16] ;


	for (int i =0 ; i<13 ; i=i+4)
	{
		temp = plaintext [i] ^ plaintext [i+1] ^ plaintext [i+2] ^plaintext [i+3];

		result [i]   = plaintext [i]   ^ temp ^ (mul(2, (plaintext[i]    ^ plaintext [i+1]) ) ) ;

		result [i+1] = plaintext [i+1] ^ temp ^ (mul(2, (plaintext [i+1] ^ plaintext [i+2]) ) ) ;
		result [i+2] = plaintext [i+2] ^ temp ^ (mul(2, (plaintext [i+2] ^ plaintext [i+3]) ) ) ;	
		result [i+3] = plaintext [i+3] ^ temp ^ (mul(2, (plaintext[i+3]  ^ plaintext [i]  ) ) ) ;

	}

	return result;
}









unsigned int* mix ;
unsigned int* results;
unsigned int * shift;
unsigned int* keyarray;

unsigned int* keyex;
unsigned int* finalresult;

unsigned int* cipher (unsigned int plaintext [16] , unsigned int key [16],int n)
{
	int k=4;
	keyarray = expandkey(key);

	for (int i =0 ; i< n ; i++)
	{
		if (n == 1 )
		{
			results = addround(plaintext,key);

		}


		else 
		{
			if (i ==0)
			{
				results = addround(plaintext,key);
			}
			else
			{
				k =4;
				results = addround(finalresult,key);

			}

		}

		unsigned int temps;


		//------------------------------------- beginning of round 1------------------------------------------------------------
		for (int i=0 ; i<10 ; i++)
		{

			for (int i =0 ; i<16 ; i++)
			{

				temps = subbyte(results[i]);
				results[i]= temps;

			}
			shift = shiftrows(results);



			if (i!=9)
			{
				mix = mixcol(shift);

			}


			keyex = splitkey(keyarray,k);

			k=k+4;


			if (i !=9)
			{

				finalresult = addround(mix,keyex);
			}
			else if (i == 9)
			{

				finalresult = addround(shift,keyex);

			}
		}




	}
	return finalresult;

}

void printcipher(unsigned int cipher[16])
{
	for (int i =0 ; i<16 ; i++)
	{

		cout<<hex<<setw(2) << setfill('0')<<*(cipher +i);
	}
	cout<<endl;
}

unsigned int temp;
unsigned int tempkey; 



unsigned int* inputplain ()
{

	stringstream ss;
	int j =0;
	static unsigned int plaintext[16];
	string plaintext1;

	cin>>plaintext1; // taking plaintext from user -------------------------------------------------------------------

	for (int i =0 ; i<32 ; i=i+2)
	{
		ss.clear();
		ss.str("");
		ss << hex << plaintext1.substr(i,2);
		ss >> temp;
		plaintext [j] = temp;
		j++;
	}

	return plaintext;
}
unsigned int* inputkey ()
{
	int jkey=0;
	static unsigned int key [16];
	stringstream ss1;
	string key1;

	// taking key from user -------------------------------------------------------------------
	cin>>key1;
	for (int i =0 ; i<32 ; i=i+2)
	{
		ss1.clear();
		ss1.str("");

		ss1 << hex << key1.substr(i,2);
		ss1 >> tempkey;
		key [jkey] = tempkey;
		jkey++;
	}


	return key;
}

int main()
{
	unsigned int* output ;

	int m;
	cin>>m;
	for (int i=0 ; i<m ;i++)
	{
		unsigned int* plaintext;
		unsigned int* key;
		plaintext = inputplain();
		key = inputkey();	
		int n;
		cin>>n;
		output = cipher(plaintext,key,n);
		printcipher (output);

	}
	return 0;

}
